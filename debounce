// 售票机按键消抖模块
// 对按键输入和拨码开关输入进行消抖处理

module debounce(
    input clk_db,           // 消抖专用时钟（100Hz）
    input rst,              // 高电平有效的复位信号
    input s0_in,            // S0按键输入（销售额清零）
    input s1_in,            // S1按键输入（投入1元）
    input s2_in,            // S2按键输入（投入5元）
    input s3_in,            // S3按键输入（投入10元）
    input [3:0] sw_in,      // SW0-SW3车票选择拨码开关输入
    input sw7_in,           // SW7交易确认拨码开关输入
    output reg s0_out,      // 消抖后的S0输出（脉冲型）
    output reg s1_out,      // 消抖后的S1输出（脉冲型）
    output reg s2_out,      // 消抖后的S2输出（脉冲型）
    output reg s3_out,      // 消抖后的S3输出（脉冲型）
    output reg [3:0] sw_out,// 消抖后的SW0-SW3输出（电平型）
    output reg sw7_out      // 消抖后的SW7输出（电平型）
);

    // 消抖用移位寄存器（3位采样，确保信号稳定）
    reg [2:0] s0_shift, s1_shift, s2_shift, s3_shift;
    reg [2:0] sw0_shift, sw1_shift, sw2_shift, sw3_shift, sw7_shift;
    
    // 边沿检测用前一状态寄存器
    reg s0_prev, s1_prev, s2_prev, s3_prev;
    
    // 消抖后的稳定电平值
    reg s0_stable, s1_stable, s2_stable, s3_stable;

    // 移位寄存器采样与消抖逻辑
    always @(posedge clk_db or posedge rst) begin
        if (rst) begin
            s0_shift <= 3'b000; s1_shift <= 3'b000;
            s2_shift <= 3'b000; s3_shift <= 3'b000;
            sw0_shift <= 3'b000; sw1_shift <= 3'b000;
            sw2_shift <= 3'b000; sw3_shift <= 3'b000;
            sw7_shift <= 3'b000;
            s0_stable <= 1'b0; s1_stable <= 1'b0;
            s2_stable <= 1'b0; s3_stable <= 1'b0;
            sw_out <= 4'b0000;
            sw7_out <= 1'b0;
        end
        else begin
            // 移入新的采样值（移位寄存器右移，最新值补到最低位）
            s0_shift <= {s0_shift[1:0], s0_in};
            s1_shift <= {s1_shift[1:0], s1_in};
            s2_shift <= {s2_shift[1:0], s2_in};
            s3_shift <= {s3_shift[1:0], s3_in};
            sw0_shift <= {sw0_shift[1:0], sw_in[0]};
            sw1_shift <= {sw1_shift[1:0], sw_in[1]};
            sw2_shift <= {sw2_shift[1:0], sw_in[2]};
            sw3_shift <= {sw3_shift[1:0], sw_in[3]};
            sw7_shift <= {sw7_shift[1:0], sw7_in};
            
            // 检测3次采样是否均为高电平，确认信号稳定为高
            if (s0_shift == 3'b111) s0_stable <= 1'b1;
            else if (s0_shift == 3'b000) s0_stable <= 1'b0; // 3次采样均为低，确认稳定为低
            
            if (s1_shift == 3'b111) s1_stable <= 1'b1;
            else if (s1_shift == 3'b000) s1_stable <= 1'b0;
            
            if (s2_shift == 3'b111) s2_stable <= 1'b1;
            else if (s2_shift == 3'b000) s2_stable <= 1'b0;
            
            if (s3_shift == 3'b111) s3_stable <= 1'b1;
            else if (s3_shift == 3'b000) s3_stable <= 1'b0;
            
            // 拨码开关输出（电平型，保持稳定状态）
            if (sw0_shift == 3'b111) sw_out[0] <= 1'b1;
            else if (sw0_shift == 3'b000) sw_out[0] <= 1'b0;
            
            if (sw1_shift == 3'b111) sw_out[1] <= 1'b1;
            else if (sw1_shift == 3'b000) sw_out[1] <= 1'b0;
            
            if (sw2_shift == 3'b111) sw_out[2] <= 1'b1;
            else if (sw2_shift == 3'b000) sw_out[2] <= 1'b0;
            
            if (sw3_shift == 3'b111) sw_out[3] <= 1'b1;
            else if (sw3_shift == 3'b000) sw_out[3] <= 1'b0;
            
            if (sw7_shift == 3'b111) sw7_out <= 1'b1;
            else if (sw7_shift == 3'b000) sw7_out <= 1'b0;
        end
    end

    // 边沿检测（将稳定电平转换为脉冲输出）
    always @(posedge clk_db or posedge rst) begin
        if (rst) begin
            s0_prev <= 1'b0; s1_prev <= 1'b0;
            s2_prev <= 1'b0; s3_prev <= 1'b0;
            s0_out <= 1'b0; s1_out <= 1'b0;
            s2_out <= 1'b0; s3_out <= 1'b0;
        end
        else begin
            // 保存当前稳定电平的前一状态
            s0_prev <= s0_stable;
            s1_prev <= s1_stable;
            s2_prev <= s2_stable;
            s3_prev <= s3_stable;
            
            // 检测上升沿：当前稳定为高 & 前一状态为低 → 输出一个时钟周期的脉冲
            s0_out <= s0_stable & ~s0_prev;
            s1_out <= s1_stable & ~s1_prev;
            s2_out <= s2_stable & ~s2_prev;
            s3_out <= s3_stable & ~s3_prev;
        end
    end

endmodule
